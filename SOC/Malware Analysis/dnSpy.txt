
dnSpy is an open-source .NET assembly (C#) debugger and editor. It is typically used for reverse engineering .NET applications and analysing their code and is primarily designed for examining and 
modifying .NET assemblies in a user-friendly, interactive way. It's also capable of modifying the retrieved source code (editing), setting breakpoints, or running through the code one step at a time (debugging).


# Decompiling Malware Samples With dnSpy
Once the tool is open, we will load the malware sample by navigating to File > Open located on the upper-left side of the application.
When you get the prompt, click the following to navigate to the malware's location: This PC > Desktop > artefacts. Now that you are inside the malware sample folder, you first need to change the file type to "All Files" to see the defanged version of the binary. Next, double-click the malware sample to load it into the application.
Once the malware sample is loaded, you'll have a view like the image below. The next step is to click the Main string, which will take you to the entry point of the application.
As discussed in the previous section, the Main function in a class is the program's entry point. This means that once the application is executed, the lines of code inside that function will be run one step at a time until the end of the code block.


# Understanding the Malware Functionalities
You might have been a little overwhelmed when you saw the Main function, but don't worry; we'll discuss the other functions before building the malware execution pipeline.
Focusing on the individual functions before dealing with the Main function can be considered a modular approach. Doing this allows us to easily break down the malware's functionalities without getting bogged down with long code snippets. Moreover, it allows us to recognise some potential execution patterns that ease our overall understanding of the malware.
You can click on the items to compare the code in dnSpy. It's also advisable to read the .NET Framework documentation to learn more about the internal functions mentioned in the following sections.


# GetIt
Based on the source code, the GetIt function uses the WebRequest class from the System.Net namespace and is initialised by the function's URL argument. The name is already a giveaway that the WebRequest is being used to initiate an HTTP request to a remote URL.

// Accepts one argument, which is the URL
public static string GetIt(string url)
{
    // 1. Initialise the HttpWebRequest Class with the target URL (from the argument of the function).
    HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
    // 2. Set the user-agent of the HTTP request.
    httpWebRequest.UserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_0) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15";
    // 3. Return the response of the HTTP request.
    return new StreamReader(((HttpWebResponse)httpWebRequest.GetResponse()).GetResponseStream()).ReadToEnd();
}

Note: You can render the namespace details by hovering over the WebRequest string, similar to what you see in the image above.
By default, the HTTP method set to the WebRequest class is GET. This means we can assume that the HTTP request made by this function is a GET request.
The three lines of code inside the function can be expanded by the comments written for every line.
In other words, the `GetIt` function accepts a URL as its argument, configures the parameters needed for the HTTP GET request (custom User-Agent), and returns the value of the response.


# PostIt
Like the **GetIt** function, the PostIt function also uses the `WebRequest` class. However, you might observe that it has configured more properties than the first one. The most notable is the Method property, wherein the value is set to POST. This means that the HTTP request made by this function is a POST request, and it submits the second argument as its POST data.

// JuicyTomatoy.Program
// Token: 0x06000008 RID: 8 RVA: 0x000024B4 File Offset: 0x000006B4

// Accepts two arguments: the URL and the data to be sent
public static string PostIt(string url, string data)
{
    HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
    // 1. Converts the data argument into bytes.
    byte[] bytes = Encoding.ASCII.GetBytes(data);
    // 2. Sets the HTTP method into POST
    httpWebRequest.Method = "POST";
    httpWebRequest.ContentType = "application/x-www-form-urlencoded";
    httpWebRequest.ContentLength = (long)bytes.Length;
    httpWebRequest.UserAgent = "REDACTED";

    // 3. Prepares the data to be sent.
    using (Stream requestStream = httpWebRequest.GetRequestStream())
    {
    	requestStream.Write(bytes, 0, bytes.Length);
    }
    //4. Returns the response of the HTTP POST request
    return new StreamReader(((HttpWebResponse)httpWebRequest.GetResponse()).GetResponseStream()).ReadToEnd();
}

In simple terms, the `PostIt` function accepts an additional argument as its POST data, which is then submitted to the target URL and returns the response it received.


# Sleeper
The Sleeper function only contains a single line: a call to the `Thread.Sleep` function. The `Thread.Sleep` function accepts an integer as its argument and makes the program pause (for milliseconds) based on the value passed to it.

// JuicyTomatoy.Program
// Token: 0x06000003 RID: 3 RVA: 0x000021FD File Offset: 0x000003FD

// Accepts one argument: an integer to set the sleep timer
public static void Sleeper(int count)
{
    // Sets the program's sleep or pause in milliseconds
    Thread.Sleep(count);
}

The usage of the `Thread.Sleep` function is typical behaviour malware uses to pause its execution to evade detection.


# ExecuteCommand
Given the namespace and class name (`System.Diagnostics.Process`) of the initialised Process class (first code line), it seems this function is being used to spawn a process, according to its [Microsoft documentation](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=netframework-4.7.2). From the initialisation of the `ProcessStartInfo` properties, we can also see that the file to be executed is `cmd.exe` and that the ExecuteCommand's argument (`command` variable) is being passed as a process argument.






















